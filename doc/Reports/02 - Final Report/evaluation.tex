\section{Evaluation}
\label{ss:eval_sim}
In terms of the realisation of initially set requirements, we were able to meet them all except for the inclusion of external map sources (requirement 3b in section~\ref{sec:reqs}). This, however, was associated with the "could have" priority class and hence is an acceptable shortcoming. As our map model is based on fixed sized tiles, it would require intense translation to reproduce a map from sources like Google Maps or KML files due to their high resolution. 

\subsection*{Design}
At the beginning of the project we implemented a model-view-controller pattern. However, during the course of the implementation it became apparent, that strictly following this pattern is impractical for this particular project. In the current state of the software, the initially separated model and view are combined in the view package. An example for this consolidation are the vehicle classes. They extend the JavaFX class \textit{Rectangle}, which is used to visualise the different types of vehicles. Nonetheless, vehicles do also know their position in the map model and compute their movement on their own - both functionality that belongs to the model in a strict MVC architecture.

The methods that compute vehicle movements require numerous of checks for the vehicle's environment. An example would be the method by which a car overtakes another. Multiple tiles of the adjacent lane must first be checked for the conditions to be met for this manoeuvre to take place. The exact tiles that need to be checked currently depend on the direction of the vehicles' movement and hence these checks come with a lot of nested conditional statements. The \textit{attemptOvertake} method in the \textit{Vehicle} class exhibits a cyclomatic complexity of 34, therewith being the most complex method in our source code (see fig.~\ref{fig:heatmap}). Reducing the complexity for this method along with others would most likely improve the scaling of simulator performance with a higher number of vehicles. Implementing these changes would require a major redesign of the simulation logic and was hence deemed as infeasible to do within the short duration of this project.

Maps are persisted using the XML. Each map-file contains data for every single tile on the map. Unfortunately, the XML specification we used does not specify the grouping of tiles to an intersection, forcing us to recreate the intersections as soon as an intersection tile is encountered while reading the map. This means that the algorithm will create an intersection at the encountered tile and hence create the tiles 3 columns to the right and 3 rows down without reading any further tile information from the XML file. To ensure that intersections are created correctly, we have to create a 2D boolean array the size of the map (i.e. 40x40, 60x60 or 80x80) to keep track of tiles that have been loaded successfully. 

\subsection*{Model}
As described in section \ref{subsec:design}, we began using a discrete space model and changed to a continuous model later on. A discrete space model, often referred to as cell automaton, is easy and quick to implement, because movement of vehicles through the grid can be simulated by simply storing a two-dimensional array of cells and moving each car on a central clock tick. Nevertheless, the discrete approach did not allow us to introduce vehicle-specific attributes like acceleration and different movements speeds.
 This change was a product of improved thinking, as we realised that the restrictions imposed by a discrete space representation outweigh the benefits of the easier implementation that comes with it.

Our model currently only supports roads with four lanes and dual carriageways. As adding support for different lane models and road sizes will increase the capabilities and functionality of both simulator and editor, we consider this a suitable task for further development of the software.


\subsection*{Team Work}
All five group members were involved in the creation of the code. Collaboration and communication was eased through extensive use of the Git Issues feature to track problems and progress in solving them (cf. section~\ref{sec:team_work}). Working in separate branches of the repository when working on the same files or related behaviour allowed every team member to contribute to the codebase continuously.  
